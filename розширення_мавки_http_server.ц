взяти визначення РМв1;

структура xxx_header {
  key: адреса<char>;
  value: адреса<char>;
}
синонім xxx_respond = (request: адреса, status: int, headers: адреса<xxx_header>, headers_size: int, data: адреса<char>, data_size: int) -> ніщо;

зовнішня дія start_http_server(port: int, handler: (request: адреса, method: адреса<char>, path: адреса<char>, headers: адреса<xxx_header>, headers_size: int, body: адреса<char>, body_size: int, respond: xxx_respond, data: адреса) -> ніщо, data: адреса);

структура ДаніОбробникаЗапиту {
  Р: адреса<РМв1::Розширення>;
  обробник: адреса<РМв1::Обʼєкт>;
}

структура ДаніНативноїДіїВідповісти {
  request: адреса;
  respond: xxx_respond;
}

дія нативна_дія_відповісти(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, обʼєкт_я: адреса<РМв1::Обʼєкт>, кількість_аргументів: позитивне, аргументи: адреса<адреса<РМв1::Обʼєкт>>, іменовані_аргументи: адреса, дані: адреса): РМв1::Результат {
  ціль дані_нативної_дії_відповісти = дані як адреса<ДаніНативноїДіїВідповісти>;
  якщо кількість_аргументів > 2 {
    ціль аргумент_статусу = аргументи[0];
    ціль аргумент_заголовків = аргументи[1];
    ціль аргумент_тіла = аргументи[2];
    ціль статус = позитивне(РМв1::отримати_значення_числа(аргумент_статусу, Р));
    ціль заголовки: адреса<xxx_header> = пусто;
    ціль розмір_заголовків: позитивне = 0;
    ціль дані: адреса<п8> = пусто;
    ціль розмір_даних: позитивне = 0;
    якщо аргумент_тіла == пусто {
      // ок
    } інакше якщо РМв1::перевірити_чи_обʼєкт_є_байтами(аргумент_тіла, Р) == так {
      розмір_даних = РМв1::отримати_копію_даних_байтів(аргумент_тіла, Р, дані::адреса);
    } інакше якщо РМв1::перевірити_чи_обʼєкт_є_текстом(аргумент_тіла, Р) == так {
      розмір_даних = РМв1::отримати_копію_даних_тексту(аргумент_тіла, Р, дані::адреса);
    } інакше якщо РМв1::перевірити_чи_обʼєкт_є_юнікодом(аргумент_тіла, Р) == так {
      розмір_даних = РМв1::отримати_копію_даних_юнікоду_як_Ю8(аргумент_тіла, Р, дані::адреса);
    } інакше {
      вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Невідомий тип тіла"));
    }
    дані_нативної_дії_відповісти.respond(дані_нативної_дії_відповісти.request, int(статус), заголовки, int(розмір_заголовків), дані як адреса<char>, int(розмір_даних));
    якщо дані != пусто {
      РМв1::звільнити(Р, дані);
    }
    вернути РМв1::успіх(Р, пусто);
  }
  вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Недостатньо аргументів"));
}

дія відклик_перед_звільненням_нативної_дії_відповісти(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, дані: адреса) {
  ціль дані_нативної_дії_відповісти = дані як адреса<ДаніНативноїДіїВідповісти>;
  РМв1::звільнити(Р, дані_нативної_дії_відповісти);
}

дія http_request_handler(request: адреса, method: адреса<char>, path: адреса<char>, headers: адреса<xxx_header>, headers_size: int, body: адреса<char>, body_size: int, respond: xxx_respond, data: адреса) {
  ціль дані_обробника_запиту = data як адреса<ДаніОбробникаЗапиту>;
  ціль Р = дані_обробника_запиту.Р;
  ціль обробник = дані_обробника_запиту.обробник;
  ціль аргументи = РМв1::виділити<адреса<РМв1::Обʼєкт>>(Р, 5);
  аргументи[0] = РМв1::створити_юнікод_з_Ю8(Р, method як адреса<п8>);
  аргументи[1] = РМв1::створити_юнікод_з_Ю8(Р, path як адреса<п8>);
  ціль обʼєкт_заголовків = РМв1::створити_словник(Р);
  змінна ціль п: int = 0;
  поки п < headers_size {
//    ціль результат_зміни_елемента = РМв1::обʼєкт_змінити_елемент(обʼєкт_заголовків, Р, РМв1::створити_юнікод_з_Ю8(Р, headers[п].key як адреса<п8>), РМв1::створити_юнікод_з_Ю8(Р, headers[п].value як адреса<п8>));
//    якщо результат_зміни_елемента.падіння != пусто {
//      // обробити
//    }
    п += 1;
  }
  аргументи[2] = обʼєкт_заголовків;
  ціль обʼєкт_тіла = РМв1::створити_байти(Р, позитивне(body_size));
  РМв1::записати_в_байти(обʼєкт_тіла, Р, body як адреса<п8>, позитивне(body_size), 0);
  аргументи[3] = обʼєкт_тіла;
  ціль дані_нативної_дії_відповісти = РМв1::виділити<ДаніНативноїДіїВідповісти>(Р);
  дані_нативної_дії_відповісти.request = request;
  дані_нативної_дії_відповісти.respond = respond;
  аргументи[4] = РМв1::створити_нативну_дію(Р, РМв1::назва_з_Ю8(Р, ю8"відповісти"), нативна_дія_відповісти, дані_нативної_дії_відповісти, відклик_перед_звільненням_нативної_дії_відповісти);
  ціль результат_обробника = РМв1::обʼєкт_виконати(обробник, Р, пусто, 5, аргументи);
  РМв1::звільнити(Р, аргументи);
  якщо результат_обробника.падіння == пусто {
  } інакше {
    РМв1::обробити_падіння(Р, результат_обробника.падіння, результат_обробника.значення);
  }
}

дія нативна_дія_http_server(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, обʼєкт_я: адреса<РМв1::Обʼєкт>, кількість_аргументів: позитивне, аргументи: адреса<адреса<РМв1::Обʼєкт>>, іменовані_аргументи: адреса, дані: адреса): РМв1::Результат {
  якщо кількість_аргументів > 1 {
    ціль аргумент_порта = аргументи[0];
    ціль аргумент_обробника = аргументи[1];
    ціль порт = позитивне(РМв1::отримати_значення_числа(аргумент_порта, Р));
    ціль дані_обробника_запиту = РМв1::виділити<ДаніОбробникаЗапиту>(Р);
    дані_обробника_запиту.Р = Р;
    дані_обробника_запиту.обробник = аргументи[1];
    РМв1::зберегти_обʼєкт(Р, аргументи[1]);
    start_http_server(int(порт), http_request_handler, дані_обробника_запиту);
    РМв1::видалити_збережений_обʼєкт(Р);
    вернути РМв1::успіх(Р, пусто);
  }
  вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Недостатньо аргументів"));
}

зовнішня дія завантажити_РМв1(Р: адреса<РМв1::Розширення>): РМв1::Результат {
  ціль обʼєкт_нативної_дії_http_server = РМв1::створити_нативну_дію(Р, РМв1::назва_з_Ю8(Р, ю8"http_server"), нативна_дія_http_server, пусто, пусто);
  вернути РМв1::успіх(Р, обʼєкт_нативної_дії_http_server);
}