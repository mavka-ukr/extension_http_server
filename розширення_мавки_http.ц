взяти визначення РМв1;

структура MavkaHTTPExtHeader {
  key: адреса<char>;
  value: адреса<char>;
}
синонім MavkaHTTPExtResponseSender = (request_data: адреса, status: int, headers: адреса<MavkaHTTPExtHeader>, headers_size: int, data: адреса<char>, data_size: int) -> ніщо;

синонім MavkaHTTPExtCallback = (error: адреса<char>, data: адреса) -> ніщо;

зовнішня дія start_http_server(port: int, handler: (request_data: адреса, method: адреса<char>, path: адреса<char>, headers: адреса<MavkaHTTPExtHeader>, headers_size: int, body: адреса<char>, body_size: int, respond: MavkaHTTPExtResponseSender, data: адреса) -> ніщо, handler_data: адреса, callback: MavkaHTTPExtCallback, callback_data: адреса);

зовнішня дія strcmp(a: адреса<char>, b: адреса<char>): int;

структура ДаніОбробникаЗапиту {
  Р: адреса<РМв1::Розширення>;
  обробник: адреса<РМв1::Обʼєкт>;
}

структура ДаніНативноїДіїВідповісти {
  request_data: адреса;
  respond: MavkaHTTPExtResponseSender;
}

структура ДаніВідкликуСервера {
  Р: адреса<РМв1::Розширення>;
  обробник: адреса<РМв1::Обʼєкт>;
}

дія нативна_дія_відповісти(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, обʼєкт_я: адреса<РМв1::Обʼєкт>, кількість_аргументів: позитивне, аргументи: адреса<адреса<РМв1::Обʼєкт>>, іменовані_аргументи: адреса<РМв1::ІменованіАргументи>, дані: адреса): РМв1::Результат {
  ціль дані_нативної_дії_відповісти = дані як адреса<ДаніНативноїДіїВідповісти>;
  змінна ціль знайдено_аргумент_статус = ні;
  ціль аргумент_статус: адреса<РМв1::Обʼєкт> = пусто;
  змінна ціль знайдено_аргумент_заголовки = ні;
  ціль аргумент_заголовки: адреса<РМв1::Обʼєкт> = пусто;
  змінна ціль знайдено_аргумент_тіло = ні;
  ціль аргумент_тіло: адреса<РМв1::Обʼєкт> = пусто;
  якщо іменовані_аргументи != пусто {
    знайдено_аргумент_статус = РМв1::знайти_іменований_аргумент(Р, іменовані_аргументи, РМв1::назва_з_Ю8(Р, ю8"статус"), аргумент_статус::адреса);
    знайдено_аргумент_заголовки = РМв1::знайти_іменований_аргумент(Р, іменовані_аргументи, РМв1::назва_з_Ю8(Р, ю8"заголовки"), аргумент_заголовки::адреса);
    знайдено_аргумент_тіло = РМв1::знайти_іменований_аргумент(Р, іменовані_аргументи, РМв1::назва_з_Ю8(Р, ю8"тіло"), аргумент_тіло::адреса);
  }
  якщо кількість_аргументів > 0 {
    якщо знайдено_аргумент_статус == ні {
      знайдено_аргумент_статус = так;
      аргумент_статус = аргументи[0];
    }
    якщо кількість_аргументів > 1 {
      якщо знайдено_аргумент_заголовки == ні {
        знайдено_аргумент_заголовки = так;
        аргумент_заголовки = аргументи[1];
      }
      якщо кількість_аргументів > 2 {
        якщо знайдено_аргумент_тіло == ні {
          знайдено_аргумент_тіло = так;
          аргумент_тіло = аргументи[2];
        }
      }
    }
  }
  якщо знайдено_аргумент_статус == ні {
    вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Пропущено аргумент \"статус\""));
  }
  ціль статус = позитивне(РМв1::отримати_значення_числа(аргумент_статус, Р));
  ціль заголовки: адреса<MavkaHTTPExtHeader> = пусто;
  ціль розмір_заголовків: позитивне = 0;
  якщо РМв1::перевірити_чи_обʼєкт_є_словником(аргумент_заголовки, Р) {
    ціль елементи_словника: адреса<РМв1::ЕлементСловника> = пусто;
    ціль розмір_елементів_словника = РМв1::отримати_елементи_словника(аргумент_заголовки, Р, елементи_словника::адреса);
    змінна ціль п: позитивне = 0;
    поки п < розмір_елементів_словника {
      ціль ключ = елементи_словника[п].ключ;
      ціль значення = елементи_словника[п].значення;
      якщо РМв1::перевірити_чи_обʼєкт_є_юнікодом(ключ, Р) {
        якщо РМв1::перевірити_чи_обʼєкт_є_юнікодом(значення, Р) {
          заголовки = РМв1::перевиділити<MavkaHTTPExtHeader>(Р, заголовки, розмір_заголовків + 1);
          заголовки[розмір_заголовків].key = пусто;
          РМв1::отримати_копію_даних_юнікоду_як_Ю8(ключ, Р, заголовки[розмір_заголовків].key::адреса як адреса<адреса<п8>>);
          заголовки[розмір_заголовків].value = пусто;
          РМв1::отримати_копію_даних_юнікоду_як_Ю8(значення, Р, заголовки[розмір_заголовків].value::адреса як адреса<адреса<п8>>);
        }
        розмір_заголовків += 1;
      }
      п += 1;
    }
    РМв1::звільнити(Р, елементи_словника);
  }
  ціль тіло: адреса<п8> = пусто;
  ціль розмір_даних: позитивне = 0;
  якщо аргумент_тіло == пусто {
    // ок
  } інакше якщо РМв1::перевірити_чи_обʼєкт_є_байтами(аргумент_тіло, Р) {
    розмір_даних = РМв1::отримати_копію_даних_байтів(аргумент_тіло, Р, тіло::адреса);
  } інакше якщо РМв1::перевірити_чи_обʼєкт_є_текстом(аргумент_тіло, Р) {
    розмір_даних = РМв1::отримати_копію_даних_тексту(аргумент_тіло, Р, тіло::адреса);
  } інакше якщо РМв1::перевірити_чи_обʼєкт_є_юнікодом(аргумент_тіло, Р) {
    розмір_даних = РМв1::отримати_копію_даних_юнікоду_як_Ю8(аргумент_тіло, Р, тіло::адреса);
  } інакше {
    вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Невідомий тип тіла"));
  }
  дані_нативної_дії_відповісти.respond(дані_нативної_дії_відповісти.request_data, int(статус), заголовки, int(розмір_заголовків), тіло як адреса<char>, int(розмір_даних));
  РМв1::звільнити(Р, тіло);
  вернути РМв1::успіх(Р, пусто);
}

дія відклик_перед_звільненням_нативної_дії_відповісти(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, дані: адреса) {
  ціль дані_нативної_дії_відповісти = дані як адреса<ДаніНативноїДіїВідповісти>;
  РМв1::звільнити(Р, дані_нативної_дії_відповісти);
}

дія http_request_handler(request_data: адреса, method: адреса<char>, path: адреса<char>, headers: адреса<MavkaHTTPExtHeader>, headers_size: int, body: адреса<char>, body_size: int, respond: MavkaHTTPExtResponseSender, data: адреса) {
  ціль дані_обробника_запиту = data як адреса<ДаніОбробникаЗапиту>;
  ціль Р = дані_обробника_запиту.Р;
  ціль обробник = дані_обробника_запиту.обробник;
  ціль аргументи = РМв1::виділити<адреса<РМв1::Обʼєкт>>(Р, 5);
  аргументи[0] = РМв1::створити_юнікод_з_Ю8(Р, method як адреса<п8>);
  аргументи[1] = РМв1::створити_юнікод_з_Ю8(Р, path як адреса<п8>);
  ціль обʼєкт_заголовків = РМв1::створити_словник(Р);
  змінна ціль п: int = 0;
  поки п < headers_size {
    ціль результат_зміни_елемента = РМв1::обʼєкт_змінити_елемент(обʼєкт_заголовків, Р, РМв1::створити_юнікод_з_Ю8(Р, headers[п].key як адреса<п8>), РМв1::створити_юнікод_з_Ю8(Р, headers[п].value як адреса<п8>));
    якщо результат_зміни_елемента.падіння != пусто {
      // обробити
    }
    п += 1;
  }
  аргументи[2] = обʼєкт_заголовків;
  якщо body == пусто {
    аргументи[3] = пусто як адреса<РМв1::Обʼєкт>;
  } інакше {
    ціль обʼєкт_тіла = РМв1::створити_байти(Р, позитивне(body_size));
    РМв1::записати_в_байти(обʼєкт_тіла, Р, body як адреса<п8>, позитивне(body_size), 0);
    аргументи[3] = обʼєкт_тіла;
  }
  ціль дані_нативної_дії_відповісти = РМв1::виділити<ДаніНативноїДіїВідповісти>(Р);
  дані_нативної_дії_відповісти.request_data = request_data;
  дані_нативної_дії_відповісти.respond = respond;
  аргументи[4] = РМв1::створити_нативну_дію(Р, РМв1::назва_з_Ю8(Р, ю8"відповісти"), нативна_дія_відповісти, дані_нативної_дії_відповісти, відклик_перед_звільненням_нативної_дії_відповісти);
  ціль результат_обробника = РМв1::обʼєкт_виконати(обробник, Р, пусто, 5, аргументи, пусто);
  РМв1::звільнити(Р, аргументи);
  якщо результат_обробника.падіння == пусто {
  } інакше {
    РМв1::обробити_падіння(Р, результат_обробника.падіння, результат_обробника.значення);
  }
}

дія http_server_callback(error: адреса<char>, data: адреса) {
  ціль дані_відклику_сервера = data як адреса<ДаніВідкликуСервера>;
  ціль Р = дані_відклику_сервера.Р;
  ціль обробник = дані_відклику_сервера.обробник;
  ціль аргументи = РМв1::виділити<адреса<РМв1::Обʼєкт>>(Р, 1);
  якщо error == пусто {
    аргументи[0] = пусто як адреса<РМв1::Обʼєкт>;
  } інакше {
    аргументи[0] = РМв1::створити_юнікод_з_Ю8(Р, error як адреса<п8>);
  }
  ціль результат_обробника = РМв1::обʼєкт_виконати(обробник, Р, пусто, 1, аргументи, пусто);
  РМв1::звільнити(Р, аргументи);
  якщо результат_обробника.падіння == пусто {
  } інакше {
    РМв1::обробити_падіння(Р, результат_обробника.падіння, результат_обробника.значення);
  }
  РМв1::звільнити(Р, data);
}

дія нативна_дія_http_server(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, обʼєкт_я: адреса<РМв1::Обʼєкт>, кількість_аргументів: позитивне, аргументи: адреса<адреса<РМв1::Обʼєкт>>, іменовані_аргументи: адреса<РМв1::ІменованіАргументи>, дані: адреса): РМв1::Результат {
  змінна ціль знайдено_аргумент_порт = ні;
  ціль аргумент_порт: адреса<РМв1::Обʼєкт> = пусто;
  змінна ціль знайдено_аргумент_обробник_запитів = ні;
  ціль аргумент_обробник_запитів: адреса<РМв1::Обʼєкт> = пусто;
  змінна ціль знайдено_аргумент_відклик_сервера = ні;
  ціль аргумент_відклик_сервера: адреса<РМв1::Обʼєкт> = пусто;
  якщо іменовані_аргументи != пусто {
    знайдено_аргумент_порт = РМв1::знайти_іменований_аргумент(Р, іменовані_аргументи, РМв1::назва_з_Ю8(Р, ю8"порт"), аргумент_порт::адреса);
    знайдено_аргумент_обробник_запитів = РМв1::знайти_іменований_аргумент(Р, іменовані_аргументи, РМв1::назва_з_Ю8(Р, ю8"обробник_запитів"), аргумент_обробник_запитів::адреса);
    знайдено_аргумент_відклик_сервера = РМв1::знайти_іменований_аргумент(Р, іменовані_аргументи, РМв1::назва_з_Ю8(Р, ю8"відклик_сервера"), аргумент_відклик_сервера::адреса);
  }
  якщо кількість_аргументів > 0 {
    якщо знайдено_аргумент_порт == ні {
      знайдено_аргумент_порт = так;
      аргумент_порт = аргументи[0];
    }
    якщо кількість_аргументів > 1 {
      якщо знайдено_аргумент_обробник_запитів == ні {
        знайдено_аргумент_обробник_запитів = так;
        аргумент_обробник_запитів = аргументи[1];
      }
      якщо кількість_аргументів > 2 {
        якщо знайдено_аргумент_відклик_сервера == ні {
          знайдено_аргумент_відклик_сервера = так;
          аргумент_відклик_сервера = аргументи[2];
        }
      }
    }
  }
  якщо знайдено_аргумент_порт == ні {
    вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Пропущено аргумент \"порт\""));
  }
  якщо РМв1::перевірити_чи_обʼєкт_є_числом(аргумент_порт, Р) == ні {
    вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Аргумент \"порт\" має бути числом"));
  }
  якщо знайдено_аргумент_обробник_запитів == ні {
    вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Пропущено аргумент \"обробник_запитів\""));
  }
  якщо знайдено_аргумент_відклик_сервера == ні {
    вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Пропущено аргумент \"відклик_сервера\""));
  }
  РМв1::зберегти_обʼєкт(Р, аргумент_порт);
  РМв1::зберегти_обʼєкт(Р, аргумент_обробник_запитів);
  РМв1::зберегти_обʼєкт(Р, аргумент_відклик_сервера);
  ціль порт = позитивне(РМв1::отримати_значення_числа(аргумент_порт, Р));
  ціль дані_обробника_запиту = РМв1::виділити<ДаніОбробникаЗапиту>(Р);
  дані_обробника_запиту.Р = Р;
  дані_обробника_запиту.обробник = аргумент_обробник_запитів;
  ціль дані_відклику_сервера = РМв1::виділити<ДаніВідкликуСервера>(Р);
  дані_відклику_сервера.Р = Р;
  дані_відклику_сервера.обробник = аргумент_відклик_сервера;
  start_http_server(int(порт), http_request_handler, дані_обробника_запиту, http_server_callback, дані_відклику_сервера);
  РМв1::видалити_збережений_обʼєкт(Р);
  РМв1::видалити_збережений_обʼєкт(Р);
  РМв1::видалити_збережений_обʼєкт(Р);
  вернути РМв1::успіх(Р, пусто);
}

зовнішня дія завантажити_РМв1(Р: адреса<РМв1::Розширення>): РМв1::Результат {
  ціль обʼєкт_модуля_http = РМв1::створити_модуль(Р, РМв1::назва_з_Ю8(Р, ю8"http"));
  РМв1::зберегти_обʼєкт(Р, обʼєкт_модуля_http);
  ціль обʼєкт_нативної_дії_http_server = РМв1::створити_нативну_дію(Р, РМв1::назва_з_Ю8(Р, ю8"http_server"), нативна_дія_http_server, пусто, пусто);
  РМв1::обʼєкт_змінити_властивість(обʼєкт_модуля_http, Р, РМв1::назва_з_Ю8(Р, ю8"serve"), обʼєкт_нативної_дії_http_server);
  РМв1::видалити_збережений_обʼєкт(Р);
  вернути РМв1::успіх(Р, обʼєкт_модуля_http);
}