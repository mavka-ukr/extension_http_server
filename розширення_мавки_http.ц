взяти визначення РМв1;

структура MavkaHTTPExtHeader {
  key: адреса<char>;
  value: адреса<char>;
}
синонім MavkaHTTPExtResponseSender = (request_data: адреса, status: int, headers: адреса<MavkaHTTPExtHeader>, headers_size: int, data: адреса<char>, data_size: int) -> ніщо;

зовнішня дія start_http_server(port: int, handler: (request_data: адреса, method: адреса<char>, path: адреса<char>, headers: адреса<MavkaHTTPExtHeader>, headers_size: int, body: адреса<char>, body_size: int, respond: MavkaHTTPExtResponseSender, data: адреса) -> ніщо, data: адреса);

зовнішня дія strcmp(a: адреса<char>, b: адреса<char>): int;

структура ДаніОбробникаЗапиту {
  Р: адреса<РМв1::Розширення>;
  обробник: адреса<РМв1::Обʼєкт>;
}

структура ДаніНативноїДіїВідповісти {
  request_data: адреса;
  respond: MavkaHTTPExtResponseSender;
}

дія нативна_дія_відповісти(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, обʼєкт_я: адреса<РМв1::Обʼєкт>, кількість_аргументів: позитивне, аргументи: адреса<адреса<РМв1::Обʼєкт>>, іменовані_аргументи: адреса, дані: адреса): РМв1::Результат {
  ціль дані_нативної_дії_відповісти = дані як адреса<ДаніНативноїДіїВідповісти>;
  якщо кількість_аргументів > 2 {
    ціль аргумент_статусу = аргументи[0];
    ціль аргумент_заголовків = аргументи[1];
    ціль аргумент_тіла = аргументи[2];
    ціль статус = позитивне(РМв1::отримати_значення_числа(аргумент_статусу, Р));
    ціль заголовки: адреса<MavkaHTTPExtHeader> = пусто;
    ціль розмір_заголовків: позитивне = 0;
    якщо РМв1::перевірити_чи_обʼєкт_є_словником(аргумент_заголовків, Р) {
      ціль елементи_словника: адреса<РМв1::ЕлементСловника> = пусто;
      ціль розмір_елементів_словника = РМв1::отримати_елементи_словника(аргумент_заголовків, Р, елементи_словника::адреса);
      змінна ціль п: позитивне = 0;
      поки п < розмір_елементів_словника {
        ціль ключ = елементи_словника[п].ключ;
        ціль значення = елементи_словника[п].значення;
        якщо РМв1::перевірити_чи_обʼєкт_є_юнікодом(ключ, Р) {
          якщо РМв1::перевірити_чи_обʼєкт_є_юнікодом(значення, Р) {
            заголовки = РМв1::перевиділити<MavkaHTTPExtHeader>(Р, заголовки, розмір_заголовків + 1);
            заголовки[розмір_заголовків].key = пусто;
            РМв1::отримати_копію_даних_юнікоду_як_Ю8(ключ, Р, заголовки[розмір_заголовків].key::адреса як адреса<адреса<п8>>);
            заголовки[розмір_заголовків].value = пусто;
            РМв1::отримати_копію_даних_юнікоду_як_Ю8(значення, Р, заголовки[розмір_заголовків].value::адреса як адреса<адреса<п8>>);
          }
          розмір_заголовків += 1;
        }
        п += 1;
      }
      РМв1::звільнити(Р, елементи_словника);
    }
    ціль дані: адреса<п8> = пусто;
    ціль розмір_даних: позитивне = 0;
    якщо аргумент_тіла == пусто {
      // ок
    } інакше якщо РМв1::перевірити_чи_обʼєкт_є_байтами(аргумент_тіла, Р) {
      розмір_даних = РМв1::отримати_копію_даних_байтів(аргумент_тіла, Р, дані::адреса);
    } інакше якщо РМв1::перевірити_чи_обʼєкт_є_текстом(аргумент_тіла, Р) {
      розмір_даних = РМв1::отримати_копію_даних_тексту(аргумент_тіла, Р, дані::адреса);
    } інакше якщо РМв1::перевірити_чи_обʼєкт_є_юнікодом(аргумент_тіла, Р) {
      розмір_даних = РМв1::отримати_копію_даних_юнікоду_як_Ю8(аргумент_тіла, Р, дані::адреса);
    } інакше {
      вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Невідомий тип тіла"));
    }
    дані_нативної_дії_відповісти.respond(дані_нативної_дії_відповісти.request_data, int(статус), заголовки, int(розмір_заголовків), дані як адреса<char>, int(розмір_даних));
    якщо дані != пусто {
      РМв1::звільнити(Р, дані);
    }
    вернути РМв1::успіх(Р, пусто);
  }
  вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Недостатньо аргументів"));
}

дія відклик_перед_звільненням_нативної_дії_відповісти(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, дані: адреса) {
  ціль дані_нативної_дії_відповісти = дані як адреса<ДаніНативноїДіїВідповісти>;
  РМв1::звільнити(Р, дані_нативної_дії_відповісти);
}

дія http_request_handler(request_data: адреса, method: адреса<char>, path: адреса<char>, headers: адреса<MavkaHTTPExtHeader>, headers_size: int, body: адреса<char>, body_size: int, respond: MavkaHTTPExtResponseSender, data: адреса) {
  ціль дані_обробника_запиту = data як адреса<ДаніОбробникаЗапиту>;
  ціль Р = дані_обробника_запиту.Р;
  ціль обробник = дані_обробника_запиту.обробник;
  ціль аргументи = РМв1::виділити<адреса<РМв1::Обʼєкт>>(Р, 5);
  аргументи[0] = РМв1::створити_юнікод_з_Ю8(Р, method як адреса<п8>);
  аргументи[1] = РМв1::створити_юнікод_з_Ю8(Р, path як адреса<п8>);
  ціль обʼєкт_заголовків = РМв1::створити_словник(Р);
  змінна ціль п: int = 0;
  поки п < headers_size {
    ціль результат_зміни_елемента = РМв1::обʼєкт_змінити_елемент(обʼєкт_заголовків, Р, РМв1::створити_юнікод_з_Ю8(Р, headers[п].key як адреса<п8>), РМв1::створити_юнікод_з_Ю8(Р, headers[п].value як адреса<п8>));
    якщо результат_зміни_елемента.падіння != пусто {
      // обробити
    }
    п += 1;
  }
  аргументи[2] = обʼєкт_заголовків;
  якщо body == пусто {
    аргументи[3] = пусто як адреса<РМв1::Обʼєкт>;
  } інакше {
    ціль обʼєкт_тіла = РМв1::створити_байти(Р, позитивне(body_size));
    РМв1::записати_в_байти(обʼєкт_тіла, Р, body як адреса<п8>, позитивне(body_size), 0);
    аргументи[3] = обʼєкт_тіла;
  }
  ціль дані_нативної_дії_відповісти = РМв1::виділити<ДаніНативноїДіїВідповісти>(Р);
  дані_нативної_дії_відповісти.request_data = request_data;
  дані_нативної_дії_відповісти.respond = respond;
  аргументи[4] = РМв1::створити_нативну_дію(Р, РМв1::назва_з_Ю8(Р, ю8"відповісти"), нативна_дія_відповісти, дані_нативної_дії_відповісти, відклик_перед_звільненням_нативної_дії_відповісти);
  ціль результат_обробника = РМв1::обʼєкт_виконати(обробник, Р, пусто, 5, аргументи);
  РМв1::звільнити(Р, аргументи);
  якщо результат_обробника.падіння == пусто {
  } інакше {
    РМв1::обробити_падіння(Р, результат_обробника.падіння, результат_обробника.значення);
  }
}

дія нативна_дія_http_server(обʼєкт_нативної_дії: адреса<РМв1::Обʼєкт>, Р: адреса<РМв1::Розширення>, обʼєкт_я: адреса<РМв1::Обʼєкт>, кількість_аргументів: позитивне, аргументи: адреса<адреса<РМв1::Обʼєкт>>, іменовані_аргументи: адреса, дані: адреса): РМв1::Результат {
  якщо кількість_аргументів > 1 {
    ціль аргумент_порта = аргументи[0];
    ціль аргумент_обробника = аргументи[1];
    ціль порт = позитивне(РМв1::отримати_значення_числа(аргумент_порта, Р));
    ціль дані_обробника_запиту = РМв1::виділити<ДаніОбробникаЗапиту>(Р);
    дані_обробника_запиту.Р = Р;
    дані_обробника_запиту.обробник = аргументи[1];
    РМв1::зберегти_обʼєкт(Р, аргументи[1]);
    start_http_server(int(порт), http_request_handler, дані_обробника_запиту);
    РМв1::видалити_збережений_обʼєкт(Р);
    вернути РМв1::успіх(Р, пусто);
  }
  вернути РМв1::падіння(Р, РМв1::створити_текст_з_Ю8(Р, ю8"Недостатньо аргументів"));
}

зовнішня дія завантажити_РМв1(Р: адреса<РМв1::Розширення>): РМв1::Результат {
  ціль обʼєкт_модуля_http = РМв1::створити_модуль(Р, РМв1::назва_з_Ю8(Р, ю8"http"));
  РМв1::зберегти_обʼєкт(Р, обʼєкт_модуля_http);
  ціль обʼєкт_нативної_дії_http_server = РМв1::створити_нативну_дію(Р, РМв1::назва_з_Ю8(Р, ю8"http_server"), нативна_дія_http_server, пусто, пусто);
  РМв1::обʼєкт_змінити_властивість(обʼєкт_модуля_http, Р, РМв1::назва_з_Ю8(Р, ю8"serve"), обʼєкт_нативної_дії_http_server);
  РМв1::видалити_збережений_обʼєкт(Р);
  вернути РМв1::успіх(Р, обʼєкт_модуля_http);
}